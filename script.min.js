// START OF COMPLETE JAVASCRIPT CODE (script.js / script.min.js)

document.addEventListener('DOMContentLoaded', async () => { // Make the listener async
    // --- DOM Elements ---
    const randomTokenDisplay = document.getElementById('random-token-display');
    const tokenSelect = document.getElementById('token-select');
    const templateGallery = document.getElementById('template-gallery');
    const memeStage = document.getElementById('meme-stage');
    const memeBackground = document.getElementById('meme-background');
    const memeControls = document.getElementById('meme-controls');
    const addTextBtn = document.getElementById('add-text-btn');
    const downloadBtn = document.getElementById('download-btn');
    const fontFamilySelect = document.getElementById('font-family-select');
    const fontSizeInput = document.getElementById('font-size-input');
    const fontColorInput = document.getElementById('font-color-input');
    const strokeColorInput = document.getElementById('stroke-color-input');
    const strokeWidthInput = document.getElementById('stroke-width-input');
    const canvas = document.getElementById('meme-canvas');
    const ctx = canvas.getContext('2d');

    // --- State Variables ---
    let activeTextBox = null;
    let textboxes = []; // Array to keep track of text box elements
    let isDragging = false;
    let dragStartX, dragStartY, dragElementStartX, dragElementStartY;
    let currentBackgroundImage = null; // To hold the loaded image object for canvas drawing
    let currentObjectURL = null; // To hold the temporary Blob URL for memory management
    let currentSelectedTokenName = null; // Keep track of the selected token

    // --- Initialize tokensData as empty; it will be filled by fetching the JSON ---
    let tokensData = [];

    // --- Fetch Token Data ---
    async function loadTokenData() {
        // Construct the URL for the JSON data on GitHub Pages
        const dataUrl = 'https://Memecoinsland.github.io/meme-generator-assets/meme-data.json';
        console.log("Attempting to load token data from:", dataUrl);

        try {
            const response = await fetch(dataUrl, { cache: "no-store" }); // Add cache control maybe?
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status} fetching ${dataUrl}`);
            }
            tokensData = await response.json(); // Assign fetched data
            console.log("Token data loaded successfully:", tokensData.length, "tokens found.");
            if (!Array.isArray(tokensData)) {
                 console.error("Fetched data is not an array!", tokensData);
                 throw new Error("Fetched token data is not in the expected array format.");
            }
        } catch (error) {
            console.error("Could not load token data:", error);
            // Display a user-friendly error message on the page
            if(templateGallery) {
                templateGallery.innerHTML = `<p style="color: #ff6b6b; text-align: center; width: 100%; padding: 20px;">Error: Failed to load meme data from server (${error.message}). Please check the console or try again later.</p>`;
            }
             // You might want to disable further functionality here
            return false; // Indicate failure
        }
        return true; // Indicate success
    }

    // --- Load data and then initialize the rest ---
    const dataLoaded = await loadTokenData();

    // --- !!! IMPORTANT: Only proceed if data loaded successfully !!! ---
    if (dataLoaded) {

        // --- Utility Functions ---
        function shuffleArray(array) { let ci=array.length,ri; while(ci!=0){ri=Math.floor(Math.random()*ci);ci--;[array[ci],array[ri]]=[array[ri],array[ci]];} return array; }
        function rgbToHex(rgb) { if(!rgb || typeof rgb !== 'string') return rgb; let match=rgb.match(/^rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*[\d.]+)?\)$/); if(!match) return rgb; let r=parseInt(match[1]).toString(16).padStart(2,'0'),g=parseInt(match[2]).toString(16).padStart(2,'0'),b=parseInt(match[3]).toString(16).padStart(2,'0'); return "#"+r+g+b; }
        function parseTextShadow(shadowString) { const defaultResult = { color: '#000000', width: 0 }; if (!shadowString || shadowString === 'none') return defaultResult; try { const firstShadow = shadowString.split(/,(?![^\(]*\))/)[0].trim(); const colorMatch = firstShadow.match(/(#[0-9a-fA-F]{3,8}|rgba?\(.+?\)|[a-zA-Z]+)$/i); let color = colorMatch ? (rgbToHex(colorMatch[0]) || colorMatch[0]) : defaultResult.color; const pxMatches = firstShadow.match(/-?\d+(\.\d+)?px/g); let width = defaultResult.width; if (pxMatches?.length >= 2) width = pxMatches.reduce((max, val) => Math.max(max, Math.abs(parseFloat(val))), 0); return { color, width }; } catch (e) { return defaultResult; } }

 function initializeTokenSelection() {
            console.log("Initializing token selection...");
            randomTokenDisplay.innerHTML = ''; // Clear previous random tokens
            tokenSelect.innerHTML = '<option value="">-- Select Token --</option>'; // Reset dropdown

            if (!tokensData || tokensData.length === 0) {
                 console.error("No token data available for initialization.");
                 return;
            }

            // --- *** ADD THIS LINE TO SORT *** ---
            tokensData.sort((a, b) => a.name.localeCompare(b.name));
            // --- *** END OF ADDED LINE *** ---

            // Populate Dropdown (Now uses the sorted array)
            tokensData.forEach(token => {
                const option = document.createElement('option');
                option.value = token.name;
                option.textContent = token.name;
                tokenSelect.appendChild(option);
            });

            // Populate Random Display (using a shuffled copy *after* sorting for dropdown)
            // It's better to shuffle a copy so the main 'tokensData' remains sorted for the dropdown
            const shuffledTokens = shuffleArray([...tokensData]); // Create a shuffled copy
            const tokensToShow = shuffledTokens.slice(0, 5); // Get first 5 random from the copy

            tokensToShow.forEach(token => {
                const img = document.createElement('img');
                img.src = token.avatar;
                img.alt = token.name;
                img.dataset.tokenName = token.name; // Store token name
                img.title = `Select ${token.name}`; // Tooltip
                img.addEventListener('click', handleTokenAvatarClick);
                img.onerror = () => { img.style.display = 'none'; console.warn(`Failed to load avatar: ${token.avatar}`); }; // Hide broken avatars
                randomTokenDisplay.appendChild(img);
            });

             console.log("Token selection initialized (Dropdown sorted).");
        }

        function handleTokenAvatarClick(event) {
            const clickedTokenName = event.target.dataset.tokenName;
            if (clickedTokenName) {
                console.log(`Random token avatar clicked: ${clickedTokenName}`);
                selectToken(clickedTokenName);
            }
        }

        function handleTokenDropdownChange() {
            const selectedTokenName = tokenSelect.value;
            if (selectedTokenName) {
                console.log(`Token selected from dropdown: ${selectedTokenName}`);
                selectToken(selectedTokenName);
            } else {
                clearSceneGallery();
                clearMemeArea();
                currentSelectedTokenName = null;
                 // Remove highlight from random avatars if "-- Select --" is chosen
                 randomTokenDisplay.querySelectorAll('img').forEach(img => {
                     img.classList.remove('selected-random-token');
                 });
            }
        }

        function selectToken(tokenName) {
            console.log(`Selecting token: ${tokenName}`);
            currentSelectedTokenName = tokenName; // Update state

            // Update dropdown selection to match the clicked token
            tokenSelect.value = tokenName;

            // Highlight selected random avatar using class
            randomTokenDisplay.querySelectorAll('img').forEach(img => {
                img.classList.toggle('selected-random-token', img.dataset.tokenName === tokenName);
            });

            // Load scenes for this token
            loadScenesForToken(tokenName);
        }

        function loadScenesForToken(tokenName) {
            const token = tokensData.find(t => t.name === tokenName);
            if (!token) {
                console.error(`Token data not found for: ${tokenName}`);
                clearSceneGallery();
                clearMemeArea();
                return;
            }

            console.log(`Loading scenes for token: ${tokenName}`);
            templateGallery.innerHTML = ''; // Clear previous scenes / placeholder

            if (!token.scenes || token.scenes.length === 0) {
                console.warn(`No scenes defined for token: ${tokenName}`);
                templateGallery.innerHTML = '<p style="color: #888; text-align: center; width: 100%;">No scenes available for this token.</p>';
                clearMemeArea();
                return;
            }

            token.scenes.forEach((sceneUrl, index) => {
                const img = document.createElement('img');
                img.src = sceneUrl; // Use src directly for display
                img.dataset.src = sceneUrl; // Store for loading logic
                img.alt = `${tokenName} Scene ${index + 1}`;
                // CSS handles styles like height, border, etc.
                img.onerror = () => { img.style.display = 'none'; console.warn(`Failed to load scene thumbnail: ${sceneUrl}`); }; // Hide broken scenes
                templateGallery.appendChild(img);
            });

            // Automatically select and load the first scene
            const firstSceneImage = templateGallery.querySelector('img');
            if (firstSceneImage) {
                console.log("Automatically selecting first scene.");
                firstSceneImage.classList.add('selected-template'); // Use class for selection style
                loadAndDisplayImage(firstSceneImage.dataset.src);
            } else {
                console.warn("No valid scene images found to display for token:", tokenName);
                clearMemeArea(); // Clear if no scenes loaded
            }
        }

        function clearSceneGallery() {
             templateGallery.innerHTML = '<p style="color: #888; text-align: center; width: 100%;">Select a token above to see scenes.</p>';
        }

        function clearMemeArea() {
             console.log("Clearing meme area.");
             if (currentObjectURL) {
                 URL.revokeObjectURL(currentObjectURL);
                 // console.log("Revoked Object URL during clear:", currentObjectURL.substring(0,50)+"...");
                 currentObjectURL = null;
             }
             memeBackground.src = ""; // Clear image source
             memeBackground.alt = "Meme Background";
             currentBackgroundImage = null;
             clearTextboxes(); // Remove textboxes
             disableControls(); // Disable most controls
             downloadBtn.disabled = true; // Explicitly disable download
             addTextBtn.disabled = true; // Explicitly disable add text
        }

        // --- Core Function to Load and Display Background Image (Scene) ---
        function loadAndDisplayImage(imageUrl) {
             console.log("Attempting to load scene:", imageUrl);
             if (!imageUrl) {
                 console.warn("loadAndDisplayImage called with null/empty URL.");
                 clearMemeArea();
                 return;
             }

            memeStage.style.opacity = '0.5'; // Indicate loading

            fetch(imageUrl)
              .then(response => {
                if (!response.ok) { throw new Error(`HTTP error! Status: ${response.status} for ${imageUrl}`); }
                return response.blob();
              })
              .then(blob => {
                if (currentObjectURL) { URL.revokeObjectURL(currentObjectURL); }
                currentObjectURL = URL.createObjectURL(blob);

                const img = new Image();
                img.onload = () => {
                  console.log("Image loaded successfully via Blob URL");
                  currentBackgroundImage = img;
                  memeBackground.src = img.src;
                  memeBackground.alt = `Scene for ${currentSelectedTokenName || 'selected token'}`;

                  requestAnimationFrame(() => {
                      memeStage.style.opacity = '1';
                      console.log("Image dimensions available, stage dimensions:", memeStage.clientWidth, "x", memeStage.clientHeight);
                      downloadBtn.disabled = false;
                      addTextBtn.disabled = false;
                      clearTextboxes();
                      addDefaultTextBoxes();

                      setTimeout(() => {
                          if (textboxes.length > 0 && !activeTextBox) { setActiveTextbox(textboxes[0]); }
                          else { enableControls(); }
                          positionDefaultTextBoxes();
                      }, 50);
                   });
                };
                img.onerror = (err) => {
                  console.error("Error loading image from Blob URL:", currentObjectURL, err);
                  alert("Error loading image data. Cannot display background.");
                  memeStage.style.opacity = '1';
                  clearMemeArea();
                };
                img.src = currentObjectURL;
              })
              .catch(error => {
                console.error("Fetch error loading image:", error);
                alert(`Failed to fetch image template: ${error.message}. Check console.`);
                memeStage.style.opacity = '1';
                clearMemeArea();
              });
        }


        // --- Event Listeners ---
        tokenSelect.addEventListener('change', handleTokenDropdownChange);
        // Random token avatar clicks handled by listeners added in initializeTokenSelection

        templateGallery.addEventListener('click', (e) => {
          if (e.target.tagName === 'IMG' && e.target.dataset.src && !e.target.classList.contains('selected-template')) {
            templateGallery.querySelectorAll('img.selected-template').forEach(img => img.classList.remove('selected-template'));
            e.target.classList.add('selected-template');
            const imageUrl = e.target.dataset.src;
            console.log("Scene template clicked, loading:", imageUrl);
            loadAndDisplayImage(imageUrl);
          }
        });

        addTextBtn.addEventListener('click', () => {
          if (!currentBackgroundImage) { alert("Please select a background image first."); return; }
          createTextbox("NEW TEXT");
        });

        fontFamilySelect.addEventListener('change', updateActiveTextboxStyle);
        fontSizeInput.addEventListener('input', updateActiveTextboxStyle);
        fontColorInput.addEventListener('input', updateActiveTextboxStyle);
        strokeColorInput.addEventListener('input', updateActiveTextboxStyle);
        strokeWidthInput.addEventListener('input', updateActiveTextboxStyle);

        memeStage.addEventListener('mousedown', startDrag, true);
        document.addEventListener('mousemove', drag);
        document.addEventListener('mouseup', endDrag);
        memeStage.addEventListener('click', selectTextboxOnClick);
        memeStage.addEventListener('focusin', selectTextboxOnFocus);
        downloadBtn.addEventListener('click', generateMeme);

        // --- Text/UI Functions ---
        function createTextbox(initialText = "TEXT HERE") {
          const textBox = document.createElement('div');
          textBox.classList.add('meme-text');
          textBox.setAttribute('contenteditable', 'true');
          textBox.setAttribute('spellcheck', 'false');
          textBox.setAttribute('tabindex', '0');
          textBox.innerText = initialText;

          applyStylesFromControls(textBox);
          memeStage.appendChild(textBox);
          textboxes.push(textBox);

          requestAnimationFrame(() => {
              try {
                  if (!memeStage.contains(textBox)) return;
                  const stageWidth = memeStage.clientWidth;
                  const boxWidth = textBox.offsetWidth;
                  const initialLeft = Math.max(0, Math.round((stageWidth - boxWidth) / 2));
                  const topPos = (textboxes.length === 1) ? 10 :
                                (textboxes.length === 2) ? Math.max(10, memeStage.clientHeight - textBox.offsetHeight - 10) :
                                40 + (textboxes.length - 3) * 20;
                  const initialTop = Math.max(10, topPos);

                  textBox.style.left = `${initialLeft}px`;
                  textBox.style.top = `${initialTop}px`;
                  textBox.style.width = 'max-content';

                  console.log(`Textbox created & positioned: "${initialText}" at L=${initialLeft}, T=${initialTop}`);
                  setActiveTextbox(textBox);
              } catch (e) {
                  console.error("Error in initial textbox positioning rAF:", e);
                  textBox.style.left = '10px';
                  textBox.style.top = '40px';
                  setActiveTextbox(textBox);
              }
          });
          return textBox;
        }

        function addDefaultTextBoxes() {
            if (currentBackgroundImage && memeStage.clientHeight > 0) {
                  console.log("Clearing existing boxes before adding defaults.");
                  clearTextboxes();
                  console.log("Adding default text boxes.");
                  createTextbox("TOP TEXT");
                  createTextbox("BOTTOM TEXT");
                  // Positioning happens via positionDefaultTextBoxes called after loadAndDisplayImage
            } else {
                console.log("Skipping default text boxes: No background image or stage not ready.");
            }
        }

        function positionDefaultTextBoxes() {
             if (memeStage?.clientHeight > 0 && currentBackgroundImage && textboxes.length >= 2) {
                  const stageWidth = memeStage.clientWidth;
                  const stageHeight = memeStage.clientHeight;
                  console.log("Positioning default text boxes in stage:", stageWidth, "x", stageHeight);

                  const topBox = textboxes[0];
                  const bottomBox = textboxes[1];

                  if (topBox) {
                       requestAnimationFrame(() => {
                           if (!memeStage.contains(topBox)) return;
                           topBox.style.width = 'max-content';
                           const boxWidth = topBox.offsetWidth;
                           topBox.style.left = `${Math.max(0, Math.round((stageWidth - boxWidth) / 2))}px`;
                           topBox.style.top = '10px';
                           console.log(`Default Box 0 (TOP) positioned: L=${topBox.style.left}, T=${topBox.style.top}`);
                       });
                  }

                  if (bottomBox) {
                       requestAnimationFrame(() => {
                           if (!memeStage.contains(bottomBox)) return;
                           bottomBox.style.width = 'max-content';
                           const boxWidth = bottomBox.offsetWidth;
                           const boxHeight = bottomBox.offsetHeight;
                           bottomBox.style.left = `${Math.max(0, Math.round((stageWidth - boxWidth) / 2))}px`;
                           const topForBottom = stageHeight - boxHeight - 10;
                           bottomBox.style.top = `${Math.max(10, topForBottom)}px`;
                           console.log(`Default Box 1 (BOTTOM) positioned: L=${bottomBox.style.left}, T=${bottomBox.style.top}`);
                       });
                  }
             } else if (textboxes.length > 0) {
                 console.log("Stage/Image not ready or not enough boxes for accurate default positioning.");
             }
        }

        function clearTextboxes() {
            console.log("Clearing textboxes.");
            textboxes.forEach(box => box.remove());
            textboxes = [];
            activeTextBox = null;
        }

        function setActiveTextbox(textBoxElement) {
             if (!textBoxElement || !textboxes.includes(textBoxElement) || !memeStage.contains(textBoxElement)) {
                 if (activeTextBox) {
                     activeTextBox.classList.remove('selected-text');
                     activeTextBox.style.userSelect = 'none';
                     console.log("Deselected textbox:", activeTextBox?.innerText?.substring(0, 20) + "...");
                 }
                 activeTextBox = null;
                 enableControls();
                 return;
             }

            if (activeTextBox === textBoxElement) {
                textBoxElement.focus();
                return;
            }

            if (activeTextBox) {
                activeTextBox.classList.remove('selected-text');
                activeTextBox.style.userSelect = 'none';
            }
            activeTextBox = textBoxElement;
            activeTextBox.classList.add('selected-text');
            activeTextBox.style.userSelect = 'text';
            activeTextBox.focus();
            console.log("Selected textbox:", activeTextBox.innerText.substring(0, 20) + "...");
            updateControlsToMatchTextbox(activeTextBox);
            enableControls();
        }

        function selectTextboxOnClick(e) {
            if (e.target.classList.contains('meme-text')) {
                setActiveTextbox(e.target);
                e.stopPropagation();
            } else if (activeTextBox && !isDragging && (e.target === memeStage || e.target === memeBackground)) {
                console.log("Background clicked, deselecting text.");
                setActiveTextbox(null);
            }
        }

         function selectTextboxOnFocus(e) {
             if (e.target.classList.contains('meme-text') && activeTextBox !== e.target) {
                console.log("Textbox focused via keyboard/event.");
                setActiveTextbox(e.target);
             }
         }

        function updateControlsToMatchTextbox(textBox) {
          if (!textBox) return;
          try {
              const computedStyle = window.getComputedStyle(textBox);
              fontFamilySelect.value = textBox.style.fontFamily || computedStyle.fontFamily || "Impact, Haettenschweiler, 'Arial Narrow Bold', sans-serif";
              fontSizeInput.value = parseInt(textBox.style.fontSize) || parseInt(computedStyle.fontSize) || 40;
              fontColorInput.value = rgbToHex(textBox.style.color || computedStyle.color) || '#ffffff';
              strokeColorInput.value = textBox.dataset.outlineColor || '#000000';
              strokeWidthInput.value = textBox.dataset.outlineWidth || 2;
              console.log("Controls updated to match active textbox.");
          } catch (error) {
              console.error("Error in updateControlsToMatchTextbox:", error);
          }
        }

        function updateActiveTextboxStyle() {
          if (!activeTextBox) return;
          console.log("Updating style of active textbox from controls.");
          applyStylesFromControls(activeTextBox);
        }

        function applyStylesFromControls(textBoxElement) {
            if (!textBoxElement) return;
            const fontSize = fontSizeInput.value;
            const strokeWidth = strokeWidthInput.value;
            const fontColor = fontColorInput.value;
            const strokeColor = strokeColorInput.value;
            const fontFamily = fontFamilySelect.value;

            textBoxElement.style.fontFamily = fontFamily;
            textBoxElement.style.fontSize = `${fontSize}px`;
            textBoxElement.style.color = fontColor;
            textBoxElement.dataset.outlineColor = strokeColor;
            textBoxElement.dataset.outlineWidth = strokeWidth;

            if (strokeWidth > 0) {
                let shadows = []; const sw = Number(strokeWidth);
                 shadows = [
                     `${-sw}px ${-sw}px 0 ${strokeColor}`, `${0}px ${-sw}px 0 ${strokeColor}`, `${sw}px ${-sw}px 0 ${strokeColor}`,
                     `${-sw}px  ${0}px 0 ${strokeColor}`,                                      `${sw}px  ${0}px 0 ${strokeColor}`,
                     `${-sw}px  ${sw}px 0 ${strokeColor}`, `${0}px  ${sw}px 0 ${strokeColor}`, `${sw}px  ${sw}px 0 ${strokeColor}` ];
                textBoxElement.style.textShadow = shadows.join(', ');
            } else {
                textBoxElement.style.textShadow = 'none';
            }
        }

        function disableControls() {
          console.log("Disabling controls.");
          memeControls.querySelectorAll('select, input[type="number"], input[type="color"]').forEach(el => el.disabled = true);
          const hasImage = !!currentBackgroundImage;
          addTextBtn.disabled = !hasImage;
          downloadBtn.disabled = !hasImage;
        }

        function enableControls() {
          const hasImage = !!currentBackgroundImage;
          const hasActiveText = !!activeTextBox;
          addTextBtn.disabled = !hasImage;
          downloadBtn.disabled = !hasImage;
          memeControls.querySelectorAll('select, input[type="number"], input[type="color"]').forEach(el => {
              el.disabled = !hasActiveText;
          });
        }

        // --- Drag and Drop Logic ---
        function startDrag(e) {
            if (e.target.classList.contains('meme-text')) {
                if (e.offsetX > e.target.clientWidth || e.offsetY > e.target.clientHeight) { return; }
                if (activeTextBox !== e.target) { setActiveTextbox(e.target); }
                if (activeTextBox === e.target) {
                    isDragging = true;
                    dragStartX = e.pageX; dragStartY = e.pageY;
                    dragElementStartX = activeTextBox.offsetLeft; dragElementStartY = activeTextBox.offsetTop;
                    activeTextBox.style.cursor = 'grabbing'; activeTextBox.style.userSelect = 'none';
                     console.log("Drag Start:", activeTextBox.innerText.substring(0,10)+"...", "at", dragElementStartX, dragElementStartY);
                     e.preventDefault(); e.stopPropagation();
                }
            }
        }
        function drag(e) {
            if (!isDragging || !activeTextBox) return;
            e.preventDefault();
            const dx = e.pageX - dragStartX; const dy = e.pageY - dragStartY;
            let newLeft = dragElementStartX + dx; let newTop = dragElementStartY + dy;
            const maxLeft = memeStage.clientWidth - activeTextBox.offsetWidth;
            const maxTop = memeStage.clientHeight - activeTextBox.offsetHeight;
            newLeft = Math.max(0, Math.min(newLeft, maxLeft < 0 ? 0 : maxLeft));
            newTop = Math.max(0, Math.min(newTop, maxTop < 0 ? 0 : maxTop));
            activeTextBox.style.left = `${newLeft}px`; activeTextBox.style.top = `${newTop}px`;
        }
        function endDrag(e) {
            if (isDragging && activeTextBox) {
                 e.preventDefault();
                console.log("Drag End:", activeTextBox.innerText.substring(0,10)+"...", "at", activeTextBox.style.left, activeTextBox.style.top);
                activeTextBox.style.cursor = 'move'; activeTextBox.style.userSelect = 'text';
            }
            isDragging = false;
        }

         // --- Meme Generation ---
          async function generateMeme() {
              if (!currentBackgroundImage?.complete || currentBackgroundImage?.naturalHeight === 0) { alert("Background image is not ready."); return; }
              console.log("Starting meme generation...");
              downloadBtn.disabled = true; downloadBtn.textContent = 'Generating...';

              // Font Loading
              const fontsToLoad = new Set();
              textboxes.forEach(box => {
                   const style = window.getComputedStyle(box);
                   const fontFamily = box.style.fontFamily || style.fontFamily;
                   const fontSize = box.style.fontSize || style.fontSize;
                   const fontWeight = box.style.fontWeight || style.fontWeight || 'normal';
                   const fontStyle = box.style.fontStyle || style.fontStyle || 'normal';
                   fontsToLoad.add(`${fontStyle} ${fontWeight} ${fontSize} ${fontFamily}`);
              });
              try {
                   console.log("Attempting to load fonts:", Array.from(fontsToLoad));
                   await Promise.all(Array.from(fontsToLoad).map(font => document.fonts.load(font)));
                   console.log("Fonts loaded for canvas.");
              } catch (err) { console.warn("Font loading issue:", err); }

              // Canvas Setup & Scaling
              canvas.width = currentBackgroundImage.naturalWidth;
              canvas.height = currentBackgroundImage.naturalHeight;
              ctx.clearRect(0, 0, canvas.width, canvas.height);
              try { ctx.drawImage(currentBackgroundImage, 0, 0, canvas.width, canvas.height); }
              catch (e) { console.error("Error drawing background onto canvas:", e); alert("Error drawing background."); downloadBtn.disabled = false; downloadBtn.textContent = 'Download Meme'; return; }

              const stageWidth = memeStage.clientWidth, stageHeight = memeStage.clientHeight;
              const imgWidth = currentBackgroundImage.naturalWidth, imgHeight = currentBackgroundImage.naturalHeight;
              if (stageWidth <= 0 || stageHeight <= 0 || imgWidth <= 0 || imgHeight <= 0) { alert("Invalid image or stage dimensions."); downloadBtn.disabled = false; downloadBtn.textContent = 'Download Meme'; return; }

              const stageAspect = stageWidth / stageHeight, imgAspect = imgWidth / imgHeight;
              let renderedWidthOnStage, renderedHeightOnStage, offsetXOnStage = 0, offsetYOnStage = 0;
              if (imgAspect >= stageAspect) { renderedWidthOnStage = stageWidth; renderedHeightOnStage = renderedWidthOnStage / imgAspect; offsetYOnStage = (stageHeight - renderedHeightOnStage) / 2; }
              else { renderedHeightOnStage = stageHeight; renderedWidthOnStage = renderedHeightOnStage * imgAspect; offsetXOnStage = (stageWidth - renderedWidthOnStage) / 2; }
              if (renderedWidthOnStage <= 0) { alert("Error calculating rendered size."); downloadBtn.disabled = false; downloadBtn.textContent = 'Download Meme'; return; }
              const actualScale = canvas.width / renderedWidthOnStage;
              console.log("Canvas scale factor:", actualScale.toFixed(3));

              // Draw Text Boxes
              textboxes.forEach((textBox, i) => {
                  const text = textBox.innerText; if (!text.trim()) return;
                  const style = window.getComputedStyle(textBox);
                  console.log(`Drawing textbox ${i}: "${text.substring(0,20)}..."`);

                  // Position & Scale
                  const stageOffsetLeft = textBox.offsetLeft; const stageOffsetTop = textBox.offsetTop;
                  const relativeX = stageOffsetLeft - offsetXOnStage; const relativeY = stageOffsetTop - offsetYOnStage;
                  const canvasX = relativeX * actualScale; const canvasY = relativeY * actualScale;
                  const fontSizePx = parseFloat(textBox.style.fontSize || style.fontSize);
                  const canvasFontSize = fontSizePx * actualScale;

                  // Styles
                  const outlineWidth = parseFloat(textBox.dataset.outlineWidth || 0);
                  const outlineColor = textBox.dataset.outlineColor || 'transparent';
                  const scaledOutlineWidth = outlineWidth * actualScale;
                  const fontFamily = textBox.style.fontFamily || style.fontFamily;
                  const color = textBox.style.color || style.color;
                  const textAlign = textBox.style.textAlign || style.textAlign || 'center';
                  const fontStyle = textBox.style.fontStyle || style.fontStyle || 'normal';
                  const fontWeight = textBox.style.fontWeight || style.fontWeight || 'bold';
                  const textTransform = textBox.style.textTransform || style.textTransform || 'uppercase';

                  // Context
                  ctx.font = `${fontStyle} ${fontWeight} ${canvasFontSize}px ${fontFamily}`;
                  ctx.fillStyle = color; ctx.textAlign = textAlign; ctx.textBaseline = 'top';

                   let processedText = text;
                   if (textTransform === 'uppercase') processedText = text.toUpperCase();
                   else if (textTransform === 'lowercase') processedText = text.toLowerCase();
                   const lines = processedText.split('\n');
                   let lineHeightRatio = 1.15;
                   const cssLH = textBox.style.lineHeight || style.lineHeight;
                   if (cssLH && cssLH !== 'normal') {
                        const pLH = parseFloat(cssLH); const pFS = fontSizePx;
                        if (!isNaN(pLH) && !isNaN(pFS) && pFS > 0) lineHeightRatio = pLH / pFS;
                        else if (!isNaN(parseFloat(cssLH))) lineHeightRatio = parseFloat(cssLH);
                   }
                   const canvasLineHeight = canvasFontSize * lineHeightRatio;

                   lines.forEach((line, index) => {
                      if (!line.trim() && lines.length === 1) return;
                      const lineY = canvasY + (index * canvasLineHeight);
                      let lineX = canvasX;
                      const boxWidthScaled = textBox.offsetWidth * actualScale;
                      if (textAlign === 'center') lineX = canvasX + (boxWidthScaled / 2);
                      else if (textAlign === 'right') lineX = canvasX + boxWidthScaled;

                       // Draw Outline
                       if (scaledOutlineWidth > 0 && outlineColor && outlineColor !== 'transparent') {
                          ctx.fillStyle = outlineColor; ctx.textBaseline = 'top'; ctx.textAlign = textAlign;
                          const outlineRadius = Math.ceil(scaledOutlineWidth);
                          for (let dx = -outlineRadius; dx <= outlineRadius; dx++) {
                              for (let dy = -outlineRadius; dy <= outlineRadius; dy++) {
                                   if (dx !== 0 || dy !== 0) { try { ctx.fillText(line, lineX + dx, lineY + dy); } catch (e) { console.error("Err shadow:", e); } }
                              }
                          }
                       }
                       // Draw Main Text
                       ctx.fillStyle = color; ctx.textBaseline = 'top'; ctx.textAlign = textAlign;
                       try { ctx.fillText(line, lineX, lineY); } catch (e) { console.error("Err text:", e); }
                  });
              });
              console.log("Finished drawing text.");

              // Generate Download Link
              console.log("Generating PNG...");
              try {
                  await new Promise(resolve => setTimeout(resolve, 100)); // Small delay
                  const dataUrl = canvas.toDataURL('image/png');
                  const link = document.createElement('a'); link.href = dataUrl;
                  const filename = `${currentSelectedTokenName || 'Meme'}_${Date.now()}.png`;
                  link.download = filename;
                  document.body.appendChild(link); link.click(); document.body.removeChild(link);
                  console.log("Download initiated:", filename);
              } catch (e) {
                  console.error("Download generation error:", e); alert(`Download failed: ${e.name}. Check console.`);
                   if (e.name === 'SecurityError') { alert("CORS error. Ensure images allow cross-origin use."); }
              } finally {
                   downloadBtn.disabled = false; downloadBtn.textContent = 'Download Meme';
              }
          } // --- END generateMeme ---


        // --- Initial Setup ---
        console.log("DOM Loaded. Initializing Odin Meme Generator (Data Fetched).");
        disableControls();
        initializeTokenSelection(); // Populate lists using fetched data

        if (tokensData && tokensData.length > 0) {
            const defaultTokenName = tokensData[0].name;
            console.log(`Attempting to load default token: ${defaultTokenName}`);
            selectToken(defaultTokenName);
        } else {
            // This case should ideally be handled by loadTokenData failure
            console.error("No token data available after load attempt for initial setup.");
            clearSceneGallery();
            clearMemeArea();
        }

    } // --- END of if(dataLoaded) block ---
    else {
        console.error("Meme Generator initialization aborted due to data loading failure.");
        // Make sure UI reflects the error state (e.g., disable all buttons)
        disableControls();
        if(addTextBtn) addTextBtn.disabled = true;
        if(downloadBtn) downloadBtn.disabled = true;
        if(tokenSelect) tokenSelect.disabled = true;

    }

}); // End DOMContentLoaded

// END OF COMPLETE JAVASCRIPT CODE
